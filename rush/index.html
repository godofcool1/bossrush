<!DOCTYPE html>
<html lang="en-us">

<head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VW8CMPRWYS"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());
    gtag('config', 'G-VW8CMPRWYS');
  </script>

<body oncontextmenu="return false;">
  <meta charset="utf-8" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
  <link rel="icon" type="x-icon" href="fav.ico">
  <title>DELTARUNE BOSS RUSH!</title>
  <link rel="stylesheet" href="/chapters.css">
  <script src="jszip.min.js"></script>
  <script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"2a95fe4032ac410e9e23ff5c9d15b6fe","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
  </head>

  <body>
    <div id="game-container">
      <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
      <div class="loading">
        <div class="spinner" id="spinner"></div>
        <div class="emscripten" id="status">Loading...</div>
        <progress value="0" max="100" id="progress" hidden="1"></progress>
      </div>
      <div id="mobile-controls">
        <div id="joystick-zone"></div>
        <div id="button-zone">
          <img class="action-button" id="button-c" alt="C Button">
          <img class="action-button" id="button-x" alt="X Button">
          <img class="action-button" id="button-z" alt="Z Button">
        </div>
      </div>
      <div class="output-container" id="output-container">
        <button class="output-button" id="fullscreen" title="Toggle Fullscreen">Toggle Fullscreen?</button>
        <button class="output-button" onclick="toggleConsole()" title="Lists emscripten/GM console output and loading progress">Toggle Console!</button>
        <button class="output-button" id="stats-button" onclick="toggleFPS()" title="Toggles the external FPS Counter">Toggle FPS Counter!</button>
        <button class="output-button" onclick="toggleWASD(this)" title="Toggles Mirroring Arrow Keys to WASD for easier control">Toggle Arrow & WASD Controls!</button>
        <input id="colorpicker" type="color" onchange="changecolor(this)" title="Changes color of the canvas' surrounding areas">
        <textarea id="output"></textarea>
      </div>
      <button id="closeUIButton" onclick="hideUI()">&times;</button>
      <div id="message-container">
        <div id="messages"></div>
      </div>
    </div>

    <div id="customMessageBox" class="custom-message-box">
      <div class="custom-message-box-content">
        <p id="messageBoxText"></p>
        <button id="messageBoxConfirmBtn">OK</button>
      </div>
    </div>

    <div id="saveManagerModal" class="save-manager-modal">
      <div class="save-manager-content">
        <span class="close-button" onclick="window.SAVEManager.closeSAVEManager()">&times;</span>
        <div class="save-manager-content2">
          <span class="minimize-button" onclick="window.SAVEManager.closeSMnoreload()">&dash;</span>
          <h2>SAVE File Manager!</h2>
          <button class="output-button" onclick="toggleclear_site_cache()">Wipe all of your SAVEs?</button>
          <button id="exportAllBtn" class="output-button" onclick="SAVEManager.exportAllToZip()">Export all SAVEs to ZIP?</button>
          <h3>Current SAVE Files:</h3>
          <div id="saveFileList" class="save-file-list">
            <p style="text-align: center; color: #888;">No saves found. Try importing one or saving in-game first.</p>
          </div>
          <div class="file-upload-section">
            <h3>Import Save Files?</h3>
            <input type="file" id="uploadFileInput" accept="*" multiple>
            <input type="text" id="uploadFileNameInput" placeholder="Enter the corresponding filename (e.g., filech1_0, dr.ini / for single file only)">
            <button onclick="SAVEManager.handleUpload()">Select File(s)!</button>
          </div>
        </div>
      </div>
      <script>
        window.SAVEManager = (function() {
          function showMessageBox(message, onConfirm = null) {
            const messageBox = document.getElementById('customMessageBox');
            const messageBoxText = document.getElementById('messageBoxText');
            const messageBoxConfirmBtn = document.getElementById('messageBoxConfirmBtn');
            const messageBoxCancelBtn = document.getElementById('messageBoxCancelBtn');
            messageBoxText.textContent = message;
            messageBoxConfirmBtn.textContent = 'Alright!';
            if (messageBoxCancelBtn) {
              messageBoxCancelBtn.style.display = 'none';
            }
            messageBox.style.display = 'flex';
            messageBoxConfirmBtn.onclick = () => {
              messageBox.style.display = 'none';
              if (onConfirm) onConfirm();
            };
          }

          function confirmBox(message) {
            return new Promise((resolve) => {
              const messageBox = document.getElementById('customMessageBox');
              const messageBoxText = document.getElementById('messageBoxText');
              const messageBoxConfirmBtn = document.getElementById('messageBoxConfirmBtn');
              let messageBoxCancelBtn = document.getElementById('messageBoxCancelBtn');
              if (!messageBoxCancelBtn) {
                messageBoxCancelBtn = document.createElement('button');
                messageBoxCancelBtn.id = 'messageBoxCancelBtn';
                messageBoxCancelBtn.style.backgroundColor = '#6c757d';
                messageBoxCancelBtn.style.marginLeft = '10px';
                messageBoxConfirmBtn.parentNode.appendChild(messageBoxCancelBtn);
              }
              messageBoxText.textContent = message;
              messageBoxConfirmBtn.textContent = 'Sure!';
              messageBoxCancelBtn.textContent = 'Nah.';
              messageBoxCancelBtn.style.display = 'inline-block';
              messageBox.style.display = 'flex';
              messageBoxConfirmBtn.onclick = () => {
                messageBox.style.display = 'none';
                resolve(true);
              };
              messageBoxCancelBtn.onclick = () => {
                messageBox.style.display = 'none';
                resolve(false);
              };
            });
          }
          const DB_NAME = '/_savedata';
          const STORE_NAME = 'FILE_DATA';
          const DB_VERSION = 21;
          let db;
          async function openIndexedDB() {
            if (db) return db;
            if (!window.indexedDB) {
              showMessageBox("Your browser doesn't support IndexedDB. Save manager will not work.");
              throw new Error("IndexedDB not supported.");
            }
            const databases = await window.indexedDB.databases();
            const dbExists = databases.some(dbInfo => dbInfo.name === DB_NAME);

            if (!dbExists) {
              const errorMessage = `Database '${DB_NAME}' not found. Please save in-game first.`;
              console.log(errorMessage);
              throw new Error(errorMessage);
            }

            return new Promise((resolve, reject) => {
              const request = indexedDB.open(DB_NAME, DB_VERSION);
              request.onerror = (event) => {
                console.error("IndexedDB error:", event.target.error);
                showMessageBox("Error opening IndexedDB: " + (event.target.error ? event.target.error.message : "Unknown error"));
                reject("Error opening IndexedDB.");
              };
              request.onsuccess = (event) => {
                db = event.target.result;
                console.log("IndexedDB opened successfully.");
                resolve(db);
              };
              request.onupgradeneeded = (event) => {
                db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                  console.log(`Object store '${STORE_NAME}' not found. Waiting for game to create it.`);
                }
              };
            });
          }
          async function getSaveFiles() {
            try {
              await openIndexedDB();
              const transaction = db.transaction([STORE_NAME], 'readonly');
              const objectStore = transaction.objectStore(STORE_NAME);
              const request = objectStore.getAll();
              return new Promise((resolve, reject) => {
                request.onsuccess = (event) => {
                  const files = event.target.result;
                  const fileNamesRequest = objectStore.getAllKeys();
                  fileNamesRequest.onsuccess = (eventKeys) => {
                    const fileNames = eventKeys.target.result;
                    const result = files.map((file, index) => ({
                      name: fileNames[index],
                      data: file
                    }));
                    resolve(result);
                  };
                  fileNamesRequest.onerror = (eventKeys) => {
                    console.error("Error getting file names:", eventKeys.target.error);
                    reject("Error getting file names: " + (eventKeys.target.error ? eventKeys.target.error.message : "Unknown error"));
                  };
                };
                request.onerror = (event) => {
                  console.error("Error getting save files from object store:", event.target.error);
                  reject("Error getting save files: " + (event.target.error ? event.target.error.message : "Unknown error"));
                };
              });
            } catch (error) {
              console.error("Error in getSaveFiles:", error);
              showMessageBox("Failed to retrieve save files: " + error.message);
              return [];
            }
          }
          async function displaySaveFiles() {
            const saveFileListDiv = document.getElementById('saveFileList');
            saveFileListDiv.innerHTML = '';
            try {
              const files = await getSaveFiles();
              if (files.length === 0) {
                saveFileListDiv.innerHTML = 'No saves found. Try importing one or saving in-game first.';
                return;
              }
              files.forEach(fileEntry => {
                const fileName = fileEntry.name;
                const fileData = fileEntry.data;
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('save-file-item');
                const infoDiv = document.createElement('div');
                infoDiv.classList.add('save-file-info');
                const timestamp = fileData.timestamp ? new Date(fileData.timestamp).toLocaleString() : 'N/A';
                const size = fileData.contents ? fileData.contents.byteLength : 0;
                infoDiv.innerHTML = `
                      
                          
                          
                                      <span>
                                          <strong>File:</strong> ${fileName.replace('/_savedata/', '')}
                          
                          
                                      </span>
                                      <span>
                                          <strong>Last Modified:</strong> ${timestamp}
                          
                          
                                      </span>
                                      <span>
                                          <strong>Size:</strong> ${size} bytes
                          
                          
                                      </span>
                    `;
                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('save-file-actions');
                const downloadBtn = document.createElement('button');
                downloadBtn.textContent = 'Download';
                downloadBtn.onclick = () => downloadSaveFile(fileName, fileData.contents);
                actionsDiv.appendChild(downloadBtn);
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.onclick = async () => {
                  const confirmed = await confirmBox(`Are you sure you want to delete "${fileName}"?`);
                  if (confirmed) {
                    await deleteSaveFile(fileName);
                  }
                };
                actionsDiv.appendChild(deleteBtn);
                itemDiv.appendChild(infoDiv);
                itemDiv.appendChild(actionsDiv);
                saveFileListDiv.appendChild(itemDiv);
              });
            } catch (error) {
              console.error("Error displaying save files:", error);
              saveFileListDiv.innerHTML = `
                                      
                                      
                                      <p style="text-align: center; color: #FA1E4E;">Error loading files: ${error.message}</p>`;
            }
          }

          function downloadSaveFile(fileName, contents) {
            if (!contents) {
              showMessageBox("No content to download for this file.");
              return;
            }
            const blob = new Blob([contents], {
              type: 'application/octet-stream'
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessageBox(`File "${fileName}" downloaded.`);
          }
          async function deleteSaveFile(fileName) {
            try {
              await openIndexedDB();
              const transaction = db.transaction([STORE_NAME], 'readwrite');
              const objectStore = transaction.objectStore(STORE_NAME);
              const request = objectStore.delete(fileName);
              return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                  showMessageBox(`File "${fileName}" deleted successfully.`);
                  displaySaveFiles();
                  resolve();
                };
                request.onerror = (event) => {
                  console.error("Error deleting file:", event.target.error);
                  showMessageBox(`Error deleting file "${fileName}": ` + (event.target.error ? event.target.error.message : "Unknown error"));
                  reject("Error deleting file.");
                };
              });
            } catch (error) {
              console.error("Error in deleteSaveFile:", error);
              showMessageBox("Failed to delete save file: " + error.message);
            }
          }
          async function handleUpload() {
            const uploadFileInput = document.getElementById('uploadFileInput');
            const uploadFileNameInput = document.getElementById('uploadFileNameInput');
            const files = uploadFileInput.files;
            if (files.length === 0) {
              showMessageBox("Please select at least one file to upload.");
              return;
            }
            try {
              const uploadPromises = [];
              for (let i = 0; i < files.length; i++) {
                const file = files[i];
                let fileName = (files.length === 1 && uploadFileNameInput.value.trim()) ?
                  uploadFileNameInput.value.trim() :
                  file.name;
                fileName = fileName.replace(/^_savedata\//, '');
                fileName = fileName.replace(/^\//, '');
                if (!fileName) {
                  showMessageBox(`Invalid file name for "${file.name}" after processing. Skipping.`);
                  continue;
                }
                const arrayBuffer = await file.arrayBuffer();
                const uint8ArrayContents = new Uint8Array(arrayBuffer);
                const saveObject = {
                  timestamp: new Date(),
                  mode: 33206,
                  contents: uint8ArrayContents
                };
                const finalFileName = `/_savedata/${fileName}`;
                uploadPromises.push(saveSaveFile(finalFileName, saveObject));
              }
              await Promise.all(uploadPromises);
              showMessageBox(`${files.length} file(s) uploaded and saved successfully.`);
              uploadFileInput.value = '';
              uploadFileNameInput.value = '';
              displaySaveFiles();
            } catch (error) {
              console.error("Error uploading file(s):", error);
              showMessageBox("Failed to upload one or more files: " + error.message);
            }
          }
          async function exportAllToZip() {
            try {
              const files = await getSaveFiles();
              if (files.length === 0) {
                showMessageBox("No save files to export.");
                return;
              }
              const zip = new JSZip();
              files.forEach(fileEntry => {
                const fileName = fileEntry.name.replace(/^\/_savedata\//, '');
                const contents = fileEntry.data.contents;
                if (contents) {
                  const zipContents = (contents instanceof Int8Array) ?
                    new Uint8Array(contents.buffer) :
                    contents;
                  zip.file(fileName, zipContents);
                }
              });
              const zipBlob = await zip.generateAsync({
                type: 'blob'
              });
              const url = URL.createObjectURL(zipBlob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'DELTARUNEWeb_SAVEs.zip';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
              showMessageBox("All save files exported to DELTARUNEWeb_SAVEs.zip.");
            } catch (error) {
              console.error("Error exporting to ZIP:", error);
              showMessageBox("Failed to export to ZIP: " + error.message);
            }
          }
          async function saveSaveFile(fileName, data) {
            try {
              await openIndexedDB();
              const transaction = db.transaction([STORE_NAME], 'readwrite');
              const objectStore = transaction.objectStore(STORE_NAME);
              const request = objectStore.put(data, fileName);
              return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                  resolve();
                };
                request.onerror = (event) => {
                  console.error("Error saving file:", event.target.error);
                  showMessageBox("Error saving file: " + (event.target.error ? event.target.error.message : "Unknown error"));
                  reject("Error saving file.");
                };
              });
            } catch (error) {
              console.error("Error in saveSaveFile:", error);
              showMessageBox("Failed to save file: " + error.message);
            }
          }
          async function openSAVEManager() {
            const saveManagerModal = document.getElementById('saveManagerModal');
            saveManagerModal.style.display = 'flex';
            await displaySaveFiles();
            GM_pause();
          }

          function closeSAVEManager() {
            window.location.reload();
            const saveManagerModal = document.getElementById('saveManagerModal');
            saveManagerModal.style.display = 'none';
          }

          function closeSMnoreload() {
            const saveManagerModal = document.getElementById('saveManagerModal');
            saveManagerModal.style.display = 'none';
            GM_unpause();
          }
          let uploadFileNameInput = null;

          function protectInputFromGame(e) {
            if (uploadFileNameInput && document.activeElement === uploadFileNameInput) {
              e.stopImmediatePropagation();
            }
          }
          document.addEventListener('DOMContentLoaded', () => {
            uploadFileNameInput = document.getElementById('uploadFileNameInput');
            const uploadFileInput = document.getElementById('uploadFileInput');

            if (uploadFileInput && uploadFileNameInput) {
              if (uploadFileInput && uploadFileNameInput) {
                uploadFileInput.addEventListener('change', () => {
                  if (uploadFileInput.files.length === 1) {
                    uploadFileNameInput.disabled = false;
                    uploadFileNameInput.value = uploadFileInput.files[0].name;
                    uploadFileNameInput.placeholder = 'Enter the corresponding filename (e.g., filech1_0, dr.ini / for single file only)';
                  } else {
                    uploadFileNameInput.disabled = true;
                    uploadFileNameInput.value = '';
                    uploadFileNameInput.placeholder = 'Custom filenames do not work when selecting multiple files!';
                  }
                });
              }
            }
            if (uploadFileNameInput) {
              window.addEventListener('keydown', protectInputFromGame, true);
              window.addEventListener('keyup', protectInputFromGame, true);
              window.addEventListener('keypress', protectInputFromGame, true);
            }
          });
          return {
            openSAVEManager: openSAVEManager,
            closeSAVEManager: closeSAVEManager,
            closeSMnoreload: closeSMnoreload,
            handleUpload: handleUpload,
            showMessageBox: showMessageBox,
            confirmBox: confirmBox,
            openIndexedDB: openIndexedDB,
            exportAllToZip: exportAllToZip
          };
        })();
        window.addEventListener('load', async () => {
          try {
            await window.SAVEManager.openIndexedDB();
          } catch (error) {
            console.error("Failed to initialize IndexedDB on load:", error);
          }
        });
        (function() {
          const originalLog = console.log;
          console.log = function(...args) {
            originalLog.apply(console, args);
            if (args.includes("Heading back to deltarune.win...")) {
              window.location.href = '/play/play.html';
            }
          };
        })();
        (function() {
          const originalLog = console.log;
          console.log = function(...args) {
            originalLog.apply(console, args);
            if (args.includes("Continuing to Chapter 2...")) {
              window.location.href = '/chapter2/';
            }
          };
        })();
        (function() {
          const originalLog = console.log;
          console.log = function(...args) {
            originalLog.apply(console, args);
            if (args.includes("ERROR in")) {
              if (confirm("Heya! Seems like DELTARUNE has crashed! Would you like to reload the page?")) {
                location.reload();
              }
            }
          };
        })();
      </script>
      <script>
        function showToggleMessage(button, message) {
          const oldMessage = document.querySelector('.toggle-feedback');
          if (oldMessage) oldMessage.remove();

          const rect = button.getBoundingClientRect();
          const popup = document.createElement('div');
          popup.textContent = message;
          Object.assign(popup.style, {
            position: 'absolute',
            backgroundColor: 'rgba(255, 255, 255, 0.9)',
            color: '#1a1a1a',
            padding: '6px 12px',
            borderRadius: '15px',
            fontFamily: 'sans-serif',
            fontSize: '13px',
            fontWeight: 'bold',
            zIndex: '9999',
            pointerEvents: 'none',
            left: `${rect.left + rect.width / 2}px`,
            top: `${rect.top}px`,
            transform: 'translate(-50%, -110%)',
            opacity: '1',
            transition: 'opacity 0.4s ease-out, transform 0.4s ease-out'
          });

          document.body.appendChild(popup);
          setTimeout(() => {
            popup.style.opacity = '0';
            popup.style.transform = 'translate(-50%, -160%)';
          }, 800);
          setTimeout(() => popup.remove(), 1200);
        }

        function simulateKeyEvent(eventType, key, keyCode) {
          const event = new KeyboardEvent(eventType, {
            key: key,
            keyCode: keyCode,
            which: keyCode,
            bubbles: true,
            cancelable: true,
          });
          document.dispatchEvent(event);
        }

        (function(window) {
          const WASD_CONTROLLER = {
            isEnabled: false,
            boundHandler: null,

            eventTarget: document.body,

            keyMap: {
              'w': {
                key: 'ArrowUp',
                code: 'ArrowUp',
                keyCode: 38
              },
              'a': {
                key: 'ArrowLeft',
                code: 'ArrowLeft',
                keyCode: 37
              },
              's': {
                key: 'ArrowDown',
                code: 'ArrowDown',
                keyCode: 40
              },
              'd': {
                key: 'ArrowRight',
                code: 'ArrowRight',
                keyCode: 39
              },
              'W': {
                key: 'ArrowUp',
                code: 'ArrowUp',
                keyCode: 38
              },
              'A': {
                key: 'ArrowLeft',
                code: 'ArrowLeft',
                keyCode: 37
              },
              'S': {
                key: 'ArrowDown',
                code: 'ArrowDown',
                keyCode: 40
              },
              'D': {
                key: 'ArrowRight',
                code: 'ArrowRight',
                keyCode: 39
              }
            },

            handleKeyEvent: function(event) {
              if (!this.isEnabled) return;

              const targetNode = event.target.nodeName.toLowerCase();
              if (targetNode === 'input' || targetNode === 'textarea' || event.target.isContentEditable) {
                return;
              }

              const keyData = this.keyMap[event.key];

              if (keyData) {

                event.preventDefault();
                event.stopPropagation();

                const arrowKeyEvent = new KeyboardEvent(event.type, {
                  key: keyData.key,
                  code: keyData.code,
                  bubbles: true,
                  cancelable: true,
                  composed: true,
                });

                Object.defineProperty(arrowKeyEvent, 'keyCode', {
                  value: keyData.keyCode,
                  writable: false
                });
                Object.defineProperty(arrowKeyEvent, 'which', {
                  value: keyData.keyCode,
                  writable: false
                });

                this.eventTarget.dispatchEvent(arrowKeyEvent);
              }
            },

            enable: function() {
              if (this.isEnabled) return;
              this.boundHandler = this.boundHandler || this.handleKeyEvent.bind(this);

              document.addEventListener('keydown', this.boundHandler, true);
              document.addEventListener('keyup', this.boundHandler, true);
              this.isEnabled = true;
              console.log('WASD -> arrow key control has been ENABLED! Target:', this.eventTarget);
            },

            disable: function() {
              if (!this.isEnabled || !this.boundHandler) return;
              document.removeEventListener('keydown', this.boundHandler, true);
              document.removeEventListener('keyup', this.boundHandler, true);
              this.isEnabled = false;
              console.log('WASD -> arrow key control has been DISABLED!');
            },

            toggle: function(button) {
              if (this.isEnabled) {
                this.disable();
                showToggleMessage(button, 'Toggled off!');
              } else {
                this.enable();
                showToggleMessage(button, 'Toggled on!');
              }
            }
          };

          window.toggleWASD = function(button) {
            WASD_CONTROLLER.toggle(button);
          };

        })(window);
      </script>
      <script>
        const konamiCode = ['p', 'i', 'e'];
        let konamiIndex = 0;

        function hideUI() {
          document.getElementById('output-container').classList.remove('visible');
          document.getElementById('message-container').classList.add('hidden-ui');
          document.getElementById('closeUIButton').style.display = 'none';
        }

        function showUI() {
          document.getElementById('output-container').classList.add('visible');
          document.getElementById('message-container').classList.remove('hidden-ui');
          document.getElementById('closeUIButton').style.display = 'block';
          ensureAspectRatio();
        }
        document.addEventListener('keydown', (e) => {
          if (e.key === konamiCode[konamiIndex]) {
            konamiIndex++;
            if (konamiIndex === konamiCode.length) {
              showUI();
              konamiIndex = 0;
            }
          } else {
            konamiIndex = 0;
          }
        });
        window.addEventListener('load', () => {
          document.getElementById('output-container').classList.remove('visible');
          document.querySelector('.loading').classList.add('hidden-ui');
          document.getElementById('message-container').classList.add('hidden-ui');
          document.getElementById('closeUIButton').style.display = 'none';
        });
      </script>
      <script type="text/javascript">
        function changecolor(el) {
          document.body.style.backgroundColor = el.value;
        }
        const CHANGE_ASPECT_RATIO = true;
        var bodyElement = document.getElementsByTagName("body")[0];
        var statusElement = document.getElementById("status");
        var progressElement = document.getElementById("progress");
        var spinnerElement = document.getElementById("spinner");
        var canvasElement = document.getElementById("canvas");
        var outputElement = document.getElementById("output");
        var outputContainerElement = document.getElementById("output-container");
        const messageContainerElement = document.getElementById("message-container");
        const messagesElement = document.getElementById("messages");
        let rollbackMessages = [];
        const CONSOLE_layer_set_visible = "layer_set_visible() - could not find specified layer in current room";
        const CONSOLE_layer_tilemap_get_id = "layer_tilemap_get_id() - specified tilemap not found";
        const CONSOLE_layer_depth = "layer_depth() - can't find specified layer";
        const CONSOLE_draw_tilemap = "draw_tilemap() - couldn't find specified tilemap";
        const CONSOLE_layer_get_all_elements = "layer_get_all_elements() - can't find specified layer";
        let clearRollbackMessagesTimeoutId = -1;
        const showRollbackMessage = function(message) {
          let messages = "";
          rollbackMessages.push(message);
          rollbackMessages.forEach(m => messages += " < p > " + m + " < /p>");
          messagesElement.innerHTML = messages;
          messageContainerElement.style.display = 'block';
          if (clearRollbackMessagesTimeoutId === -1) {
            clearTimeout(clearRollbackMessagesTimeoutId);
          }
          clearRollbackMessagesTimeoutId = setTimeout(clearRollbackMessages, 5000);
        };
        const clearRollbackMessages = function() {
          clearRollbackMessagesTimeoutId = -1;
          rollbackMessages = [];
          messageContainerElement.style.display = 'none';
        };
        var loadprogress = 0;
        var startingHeight, startingWidth;
        var startingAspect;
        var Module = {
          preRun: [],
          postRun: [],
          print: (function() {
            var element = document.getElementById("output");
            if (element) element.value = "";
            return function(text) {
              if (text === "Starting WAD") {
                loadprogress += 1;
              }
              if (loadprogress === 1) {
                Module.setStatus(text);
              } else if (loadprogress >= 2) {
                Module.setStatus("");
              }
              if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(" ");
              if (text != CONSOLE_layer_set_visible && text != CONSOLE_layer_tilemap_get_id && text != CONSOLE_layer_depth && text != CONSOLE_draw_tilemap && text != CONSOLE_layer_get_all_elements) {
                console.log(text);
              }
              if (text === "Entering main loop.") {
                ensureAspectRatio();
                loadprogress += 1;
              }
              if (element) {
                if (text != CONSOLE_layer_set_visible && text != CONSOLE_layer_tilemap_get_id && text != CONSOLE_layer_depth && text != CONSOLE_draw_tilemap && text != CONSOLE_layer_get_all_elements) {
                  element.value += text + "\n";
                }
                element.scrollTop = element.scrollHeight;
              }
            };
          })(),
          printErr: function(text) {
            if (arguments.length > 1) text = Array.prototype.slice.call(arguments).join(" ");
            console.error(text);
          },
          canvas: (function() {
            return document.getElementById("canvas");
          })(),
          setStatus: function(text) {
            if (!Module.setStatus.last) Module.setStatus.last = {
              time: Date.now(),
              text: ""
            };
            if (text === Module.setStatus.last.text) return;
            var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
            var now = Date.now();
            if (m && now - Module.setStatus.last.time < 30) return;
            Module.setStatus.last.time = now;
            Module.setStatus.last.text = text;
            if (m) {
              text = m[1];
              progressElement.value = parseInt(m[2]) * 100;
              progressElement.max = parseInt(m[4]) * 100;
              progressElement.hidden = false;
              spinnerElement.hidden = false;
            } else {
              progressElement.value = null;
              progressElement.max = null;
              progressElement.hidden = true;
              if (!text) {
                spinnerElement.style.display = "none";
                canvasElement.style.display = "block";
              }
            }
            statusElement.innerHTML = text;
          },
          totalDependencies: 0,
          monitorRunDependencies: function(left) {
            this.totalDependencies = Math.max(this.totalDependencies, left);
            Module.setStatus(left ? "Preparing... (" + (this.totalDependencies - left) + "/" + this.totalDependencies + ")" : "All downloads complete.");
          },
        };
        Module.setStatus("Downloading...");
        window.onerror = function(event) {
          spinnerElement.style.display = "none";
          Module.setStatus = function(text) {
            if (text) Module.printErr("[post-exception status] " + text);
          };
        };
        if (typeof window === "object") {
          Module['arguments'] = window.location.search.substr(1).trim().split('&');
          if (!Module['arguments'][0]) {
            Module['arguments'] = [];
          }
        }

        function toggleConsole() {
          var isShown = outputElement.style.display === "flex";
          if (isShown) {
            outputElement.style.display = "none";
            outputElement.scrollIntoView(false);
          } else {
            outputElement.style.display = "flex";
            outputElement.scrollIntoView(true);
          }
        }

        async function toggleclear_site_cache() {

          const confirmed = await window.SAVEManager.confirmBox("This will clear the site cache. Most importantly, this will ALSO clear ALL OF YOUR SAVES. ONLY do this if you know what you are doing or if the site/game crashes repeatedly. Still wanna continue?");
          if (confirmed) {
            try {
              const dbs = await window.indexedDB.databases();
              dbs.forEach(db => {
                window.indexedDB.deleteDatabase(db.name)
              });
              window.SAVEManager.showMessageBox("All site data has been cleared!\nPlease reload the page for it to take effect.");
            } catch (error) {
              console.error("Error clearing IndexedDB:", error);
              window.SAVEManager.showMessageBox("Failed to clear site data. Error: " + error.message);
            }
          }
        }
        var stopfps = 0;

        (function(window) {

          let stats = null;
          let isLoaded = false;
          let isVisible = false;

          function animationLoop() {
            if (stats) {
              stats.update();
              requestAnimationFrame(animationLoop);
            }
          }

          function init() {

            stats = new Stats();

            stats.showPanel(0);

            document.body.appendChild(stats.dom);

            requestAnimationFrame(animationLoop);

            isLoaded = true;
            isVisible = true;
            console.log('FPS counter initialized!');
          }

          function toggle() {

            if (!isLoaded) {
              console.log('Loading stats.js library...');

              const script = document.createElement('script');
              script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js';

              script.onload = init;

              document.head.appendChild(script);
              return;
            }

            if (isVisible) {

              stats.dom.style.display = 'none';
              isVisible = false;
              console.log('FPS counter hidden.');
            } else {

              stats.dom.style.display = 'block';
              isVisible = true;
              console.log('FPS counter shown.');
            }
          }

          window.toggleFPS = toggle;

        })(window);

        var g_pWadLoadCallback = undefined;

        function setWadLoadCallback(_wadLoadCallback) {
          g_pWadLoadCallback = _wadLoadCallback;
        }
        var g_pAddAsyncMethod = -1;

        function setAddAsyncMethod(asyncMethod) {
          g_pAddAsyncMethod = asyncMethod;
        }
        var g_pJSExceptionHandler = undefined;

        function setJSExceptionHandler(exceptionHandler) {
          if (typeof exceptionHandler == "function") {
            g_pJSExceptionHandler = exceptionHandler;
          }
        }

        function hasJSExceptionHandler() {
          return (g_pJSExceptionHandler != undefined) && (typeof g_pJSExceptionHandler == "function");
        }

        function doJSExceptionHandler(exceptionJSON) {
          if (typeof g_pJSExceptionHandler == "function") {
            var exception = JSON.parse(exceptionJSON);
            g_pJSExceptionHandler(exception);
          }
        }

        function manifestFiles() {
          return ["AUDIO_INTRONOISE.ogg", "audio-worklet.js", "fnames", "game.unx", "index.html", "mus/acid_tunnel.ogg", "mus/afterrain_inside.ogg", "mus/alarm_titlescreen.ogg", "mus/alley_ambience.ogg", "mus/alt_church_lobby.ogg", "mus/ambientwater_weird.ogg", "mus/annoying_prophecy.ogg", "mus/april_2012.ogg", "mus/AUDIO_INTRONOISE.ogg", "mus/audio_anotherhim.ogg", "mus/audio_darkness.ogg", "mus/audio_defeat.ogg", "mus/audio_drone.ogg", "mus/audio_story.ogg", "mus/baci_distort.ogg", "mus/baci_perugina.ogg", "mus/basement.ogg", "mus/battle.ogg", "mus/battle_preview.ogg", "mus/battle_preview_crisp.ogg", "mus/battle_vapor.ogg", "mus/bell_ambience.ogg", "mus/berdly_audience.ogg", "mus/berdly_battle_heartbeat_true.ogg", "mus/berdly_chase.ogg", "mus/berdly_descend.ogg", "mus/berdly_flashback.ogg", "mus/berdly_theme.ogg", "mus/bird.ogg", "mus/board4_rhythm.ogg", "mus/board_4.ogg", "mus/board_4_challenge.ogg", "mus/board_lancer_dig.ogg", "mus/board_ocean.ogg", "mus/board_sword_music.ogg", "mus/board_zelda.ogg", "mus/boxing_boss.ogg", "mus/boxing_boss_preview.ogg", "mus/boxing_boss_preview_crisp.ogg", "mus/boxing_game.ogg", "mus/card_castle.ogg", "mus/carol_appeared.ogg", "mus/castle_funk_long.ogg", "mus/castletown.ogg", "mus/castletown_empty.ogg", "mus/ch2_credits.ogg", "mus/ch3-practice_song_combined.ogg", "mus/ch3-practice_song_noguit.ogg", "mus/ch3_board1.ogg", "mus/ch3_board2.ogg", "mus/ch3_board3.ogg", "mus/ch3_karaoke_example_guit_only.ogg", "mus/ch3_karaoke_example_guitar_only_v2.ogg", "mus/ch3_karaoke_example_noguit.ogg", "mus/ch3_karaoke_example_noguitar_v2.ogg", "mus/ch3_karaoke_example_together_ex.ogg", "mus/ch3_karaoke_full.ogg", "mus/ch3_karaoke_no_guitar.ogg", "mus/ch3_karaoke_preview.ogg", "mus/ch3_karaoke_preview_crisp.ogg", "mus/ch3_south_of_the_border.ogg", "mus/ch3_tvtime.ogg", "mus/ch3_tvtime_guitar.ogg", "mus/ch4_battle.ogg", "mus/ch4_credits.ogg", "mus/ch4_extra_boss.ogg", "mus/ch4_first_intro.ogg", "mus/ch4_first_intro_breaking.ogg", "mus/charjoined.ogg", "mus/checkers.ogg", "mus/church_dark_study.ogg", "mus/church_hymn.ogg", "mus/church_lightning.ogg", "mus/church_lw.ogg", "mus/church_lw_night.ogg", "mus/church_wip.ogg", "mus/church_zone2_alt_longer_test.ogg", "mus/church_zone3.ogg", "mus/climb.ogg", "mus/coolbeat.ogg", "mus/creepychase.ogg", "mus/creepydoor.ogg", "mus/creepylandscape.ogg", "mus/cyber.ogg", "mus/cyber_battle.ogg", "mus/cyber_battle_end.ogg", "mus/cyber_battle_prelude.ogg", "mus/cyber_shop.ogg", "mus/cybercity.ogg", "mus/cybercity_alt.ogg", "mus/cybercity_old.ogg", "mus/cyberhouse.ogg", "mus/cybershop_christmas.ogg", "mus/d.ogg", "mus/dark_place.ogg", "mus/darkchurch_intro.ogg", "mus/deep_noise.ogg", "mus/dogcheck.ogg", "mus/dontforget.ogg", "mus/elevator.ogg", "mus/fanfare.ogg", "mus/field_of_hopes.ogg", "mus/field_of_hopes_preview.ogg", "mus/field_of_hopes_preview_crisp.ogg", "mus/findher.ogg", "mus/flashback_excerpt.ogg", "mus/forest.ogg", "mus/friendship.ogg", "mus/gallery.ogg", "mus/gameover_short.ogg", "mus/gerson_defeated.ogg", "mus/gerson_theme_intro.ogg", "mus/gerson_theme_nointro.ogg", "mus/giant_queen_appears.ogg", "mus/gigaqueen_pre.ogg", "mus/glacier.ogg", "mus/greenroom_detune.ogg", "mus/heartbeat.ogg", "mus/hip_shop.ogg", "mus/home.ogg", "mus/honksong.ogg", "mus/jitterbug.ogg", "mus/jitterbug_muffled.ogg", "mus/joker.ogg", "mus/keygen.ogg", "mus/kingboss.ogg", "mus/knight.ogg", "mus/knight_appears.ogg", "mus/kris_piano_lancer_waltz.ogg", "mus/kris_piano_last_prophecy.ogg", "mus/kris_piano_lower.ogg", "mus/kris_piano_prophecy.ogg", "mus/kris_piano_quiz.ogg", "mus/kris_piano_rouxls.ogg", "mus/kris_piano_sevenfour.ogg", "mus/kris_piano_shop.ogg", "mus/kris_piano_waitingroom.ogg", "mus/lancer.ogg", "mus/lancer_annoying.ogg", "mus/lancer_susie.ogg", "mus/lancerfight.ogg", "mus/legend.ogg", "mus/legend_altered.ogg", "mus/man.ogg", "mus/man_2.ogg", "mus/man_nes.ogg", "mus/mansion.ogg", "mus/mansion_entrance.ogg", "mus/me.ogg", "mus/menu.ogg", "mus/mike.ogg", "mus/mike_zone.ogg", "mus/minigame_kart.ogg", "mus/muffled_rain.ogg", "mus/mus_birdnoise.ogg", "mus/mus_confession.ogg", "mus/mus_introcar.ogg", "mus/mus_knightthought.ogg", "mus/mus_race.ogg", "mus/mus_school.ogg", "mus/mus_temloopshort.ogg", "mus/muscle.ogg", "mus/music_guys.ogg", "mus/music_guys_intro.ogg", "mus/napsta_alarm.ogg", "mus/nes_intro_extended_part2.ogg", "mus/newscast.ogg", "mus/night_ambience.ogg", "mus/nightmare_boss_heavy.ogg", "mus/nightmare_boss_links.ogg", "mus/nightmare_nes.ogg", "mus/noelle.ogg", "mus/noelle_distant.ogg", "mus/noelle_ferriswheel.ogg", "mus/noelle_house_wip.ogg", "mus/noelle_normal.ogg", "mus/noelle_school.ogg", "mus/noelleshouseoutside.ogg", "mus/northernlight.ogg", "mus/ocean.ogg", "mus/oldman_helps_out.ogg", "mus/ominous_message.ogg", "mus/ominous_stab_harsh.ogg", "mus/ominous_stab_harsh_2.ogg", "mus/ominous_worse.ogg", "mus/pianpian.ogg", "mus/prejoker.ogg", "mus/pumpkin_boss.ogg", "mus/queen.ogg", "mus/queen_boss.ogg", "mus/queen_car_radio.ogg", "mus/queen_intro.ogg", "mus/quiet_autumn.ogg", "mus/quiet_church.ogg", "mus/rain.ogg", "mus/raining.ogg", "mus/raining_in_church2.ogg", "mus/rhythm_knockdown_combined.ogg", "mus/rhythm_knockdown_no_guit.ogg", "mus/root_8bit.ogg", "mus/rouxls_battle.ogg", "mus/rtenna_zoom.ogg", "mus/rudebuster_boss.ogg", "mus/ruruskaado.ogg", "mus/s_neo.ogg", "mus/s_neo_clip.ogg", "mus/sadchord2.ogg", "mus/second_church.ogg", "mus/shinkansen.ogg", "mus/shop1.ogg", "mus/sinedrone_danger.ogg", "mus/sinedrone_danger_high.ogg", "mus/sink_noise.ogg", "mus/smallpiano_room.ogg", "mus/sound_battle_bg.ogg", "mus/spamton_basement.ogg", "mus/spamton_battle.ogg", "mus/spamton_dance.ogg", "mus/spamton_happy.ogg", "mus/spamton_house.ogg", "mus/spamton_laugh_noise.ogg", "mus/spamton_meeting.ogg", "mus/spamton_meeting_intro.ogg", "mus/spamton_neo_after.ogg", "mus/spamton_neo_meeting.ogg", "mus/spamton_neo_mix_ex_wip.ogg", "mus/static_placeholder.ogg", "mus/statue2_level1.ogg", "mus/statue2_level2.ogg", "mus/statue2_level3.ogg", "mus/statue2_level4.ogg", "mus/statue2_level5.ogg", "mus/statue_chord_basic.ogg", "mus/statue_level1.ogg", "mus/statue_level2.ogg", "mus/statue_level3.ogg", "mus/statue_level4.ogg", "mus/stealth.ogg", "mus/strongwind_loop.ogg", "mus/susie_diner.ogg", "mus/tenna_battle.ogg", "mus/tenna_battle_guitar.ogg", "mus/tenna_battle_old.ogg", "mus/tenna_battle_preview.ogg", "mus/tenna_battle_preview_crisp.ogg", "mus/tenna_island.ogg", "mus/tense.ogg", "mus/the_dark_truth.ogg", "mus/the_holy.ogg", "mus/thrash_rating.ogg", "mus/thrashmachine.ogg", "mus/tin_night.ogg", "mus/tinnitus.ogg", "mus/titan_battle.ogg", "mus/titan_pre.ogg", "mus/titan_spawn.ogg", "mus/titan_tower.ogg", "mus/town.ogg", "mus/town_day.ogg", "mus/trank.ogg", "mus/tv_changingroom.ogg", "mus/tv_game.ogg", "mus/tv_hall_of_fame.ogg", "mus/tv_infrontof.ogg", "mus/tv_noise.ogg", "mus/tv_results_screen.ogg", "mus/tv_static_bad.ogg", "tv_world.ogg", "mus/tvromance.ogg", "mus/vs_susie.ogg", "mus/w.ogg", "mus/wet_tapdancing.ogg", "mus/wet_tapdancing2.ogg", "mus/wet_tapdancing_failed.ogg", "mus/wind.ogg", "mus/wind_highplace.ogg", "runner-sw.js", "runner.data", "runner.js", "runner.json", "runner.svg", "runner.wasm", "runnerLocal.svg", "snd_closet_fall.ogg", "snd_closet_impact.ogg", "snd_great_shine.ogg", "snd_paper_rumble.ogg", "snd_paper_surf.ogg", "snd_revival.ogg", "snd_rurus_appear.ogg", "snd_usefountain.ogg", "sw.js"].join(";");
        }

        function onFirstFrameRendered() {}

        function onGameSetWindowSize(width, height) {
          if (startingHeight === undefined && startingWidth === undefined) {
            console.log("Initial window size set to width: " + width + ", height: " + height);
            startingHeight = height;
            startingWidth = width;
            startingAspect = startingWidth / startingHeight;
          }
        }

        function ensureAspectRatio() {
          if (canvasElement === undefined || !CHANGE_ASPECT_RATIO || startingHeight === undefined || startingWidth === undefined) {
            return;
          }
          canvasElement.classList.add("active");
          const maxWidth = window.innerWidth;
          const maxHeight = window.innerHeight;
          var newHeight, newWidth;
          var heightQuotient = startingHeight / maxHeight;
          var widthQuotient = startingWidth / maxWidth;
          if (heightQuotient > widthQuotient) {
            newHeight = maxHeight;
            newWidth = newHeight * startingAspect;
          } else {
            newWidth = maxWidth;
            newHeight = newWidth / startingAspect;
          }
          canvasElement.style.height = newHeight + "px";
          canvasElement.style.width = newWidth + "px";
          canvasElement.width = newWidth;
          canvasElement.height = newHeight;
          canvasElement.style.position = "absolute";
          canvasElement.style.left = "50%";
          canvasElement.style.top = "50%";
          canvasElement.style.transform = "translate(-50%, -50%)";
        }

        function quitIfSupported() {
          if (window.oprt && window.oprt.closeTab) {
            window.oprt.closeTab();
          } else if (window.chrome && window.chrome.runtime && window.chrome.runtime.sendMessage) {
            window.chrome.runtime.sendMessage('mpojjmidmnpcpopbebmecmjdkdbgdeke', {
              command: 'closeTab'
            });
          }
        }

        function enterFullscreenIfSupported() {
          if (!window.oprt || !window.oprt.enterFullscreen) {
            return;
          }
          window.oprt.enterFullscreen();
          let viewStatus = GM_get_view_status();
          viewStatus.fullscreen = true;
          GM_set_view_status(viewStatus);
        }

        function lockOrientationIfSupported() {
          if (!window.oprt || !window.oprt.lockPortraitOrientation || !window.oprt.lockLandscapeOrientation) {
            return;
          }
          let viewStatus = GM_get_view_status();
          if (viewStatus.landscape === true && viewStatus.portrait === false) {
            window.oprt.lockPortraitOrientation();
          } else if (viewStatus.landscape === false && viewStatus.portrait === true) {
            window.oprt.lockPortraitOrientation();
          }
        }
        const resizeObserver = new ResizeObserver(() => {
          window.requestAnimationFrame(ensureAspectRatio);
          setTimeout(() => window.requestAnimationFrame(ensureAspectRatio), 100);
        });
        resizeObserver.observe(document.body);
        if (/Android|iPhone|iPod/i.test(navigator.userAgent)) {
          bodyElement.className = "scrollingDisabled";
          outputContainerElement.hidden = true;
        }
        document.addEventListener("visibilitychange", (event) => {
          if (document.visibilityState != "visible") {}
        });
        window.addEventListener("load", (event) => {
          if ((!window.oprt || !window.oprt.enterFullscreen) && (!window.chrome || !window.chrome.runtime || !window.chrome.runtime.sendMessage)) {
            quitButton.hidden = true;
          }
        });
        setWadLoadCallback(() => {
          enterFullscreenIfSupported();
          lockOrientationIfSupported();
        });
      </script>
      <script>
        function toggleFullscreen() {
          const doc = document;
          const docEl = doc.documentElement;

          const isInFullscreen = () =>
            doc.fullscreenElement ||
            doc.webkitFullscreenElement ||
            doc.mozFullScreenElement ||
            doc.msFullscreenElement;

          const requestFullscreen = () => {
            if (docEl.requestFullscreen) docEl.requestFullscreen();
            else if (docEl.webkitRequestFullscreen) docEl.webkitRequestFullscreen();
            else if (docEl.mozRequestFullScreen) docEl.mozRequestFullScreen();
            else if (docEl.msRequestFullscreen) docEl.msRequestFullscreen();
          };

          const exitFullscreen = () => {
            if (doc.exitFullscreen) doc.exitFullscreen();
            else if (doc.webkitExitFullscreen) doc.webkitExitFullscreen();
            else if (doc.mozCancelFullScreen) doc.mozCancelFullScreen();
            else if (doc.msExitFullscreen) doc.msExitFullscreen();
          };

          if (!isInFullscreen()) {
            requestFullscreen();
          } else {
            exitFullscreen();
          }
        }
        const originalConsoleLog = console.log;
        console.log = function(...args) {
          originalConsoleLog.apply(console, args);
          if (args.some(arg => typeof arg === 'string' && arg.includes('Toggling fullscreen...'))) {
            toggleFullscreen();
          }
        };
        document.addEventListener('DOMContentLoaded', () => {
          const fullscreenButton = document.getElementById('fullscreen');
          if (fullscreenButton) {
            fullscreenButton.addEventListener('click', toggleFullscreen);
          }
        });
      </script>
      <script async type="text/javascript" src="runner.js"></script>
      <script src="/mobile.js"></script>
      <script src="/cooker.js"></script>
      <script src="nipplejs.min.js"></script>
  </body>

</html>

<!-- DELTARUNEWeb v6 -->
<!-- made with ❤️ by .shortpie. -->
<!-- credits to Toby Fox for making DELTARUNE! -->